# Day 1: Report Repair

In any case, all elements will need to be scanned, making this O(n) at best. I did wonder if there were any number tricks to pull (possibly involving logarithms), but addition and multiplication aren't exactly slow operations.

For any solution, one number must be less than or equal to 2020/2 = 1010, and the other larger, therefore the pseudocode is

* let seen = some implementation of a set
* for number:
  * if number >= 1010:
    * let complement = 2020 - number
    * if seen.contains(complement):
	  * print number * complement
	  * halt
  * if number <= 1010: [remark: yes, it is intentional that 1010 matches both branches]
    * seen.insert(number)
* assertion failed

If the arithmetic, branching, and set operations are O(1), then this solution is O(n).

Possible ways to implement the set:

* Hash set - operations are O(1) amortised
* Tree set - likely to be inferior both asymptotically and in real-world to a hash set
* Sorted dynamic array with binary search - insertion is O(1) amortised, querying is O(log n), but real world performance may well beat the hash set
* **Bit set** [Chosen] - the logical conclusion of the dynamic array with full population. 1010 is a rather small number, requiring just 127 bytes, so this solution is quite feasible even on constrained hardware
